{"ast":null,"code":"import operate from './operate';\nfunction isNumber(item) {\n  return !!item.match(/[0-9]+/);\n}\n\n/**\n * Given a button name and a calculator data object, return an updated\n * calculator data object.\n *\n * Calculator data object contains:\n *   total:s      the running total\n *   next:String       the next number to be operated on with the total\n *   operation:String  +, -, etc.\n */\nfunction calculate(obj, buttonName) {\n  if (buttonName === 'AC') {\n    return {\n      total: null,\n      next: null,\n      operation: null\n    };\n  }\n  if (isNumber(buttonName)) {\n    if (buttonName === '0' && obj.next === '0') {\n      return {};\n    }\n    // If there is an operation, update next\n    if (obj.operation) {\n      if (obj.next && obj.next !== '0') {\n        return {\n          ...obj,\n          next: obj.next + buttonName\n        };\n      }\n      return {\n        ...obj,\n        next: buttonName\n      };\n    }\n    // If there is no operation, update next and clear the value\n    if (obj.next && obj.next !== '0') {\n      return {\n        next: obj.next + buttonName,\n        total: null\n      };\n    }\n    return {\n      next: buttonName,\n      total: null\n    };\n  }\n  if (buttonName === '.') {\n    if (obj.next) {\n      if (obj.next.includes('.')) {\n        return {\n          ...obj\n        };\n      }\n      return {\n        ...obj,\n        next: `${obj.next}.`\n      };\n    }\n    if (obj.operation) {\n      return {\n        ...obj,\n        next: '0.'\n      };\n    }\n    if (obj.total) {\n      if (obj.total.includes('.')) {\n        return {};\n      }\n      return {\n        ...obj,\n        next: `${obj.total}.`\n      };\n    }\n    return {\n      ...obj,\n      next: '0.'\n    };\n  }\n  if (buttonName === '=') {\n    if (obj.next && obj.operation) {\n      return {\n        total: operate(obj.total, obj.next, obj.operation),\n        next: null,\n        operation: null\n      };\n    }\n    // '=' with no operation, nothing to do\n    return {};\n  }\n  if (buttonName === '+/-') {\n    if (obj.next) {\n      return {\n        ...obj,\n        next: (-1 * parseFloat(obj.next)).toString()\n      };\n    }\n    if (obj.total) {\n      return {\n        ...obj,\n        total: (-1 * parseFloat(obj.total)).toString()\n      };\n    }\n    return {};\n  }\n\n  // Button must be an operation\n\n  // When the user presses an operation button without having entered\n  // a number first, do nothing.\n  // if (!obj.next && !obj.total) {\n  //   return {};\n  // }\n\n  // User pressed an operation after pressing '='\n  if (!obj.next && obj.total && !obj.operation) {\n    return {\n      ...obj,\n      operation: buttonName\n    };\n  }\n\n  // User pressed an operation button and there is an existing operation\n  if (obj.operation) {\n    if (obj.total && !obj.next) {\n      return {\n        ...obj,\n        operation: buttonName\n      };\n    }\n    if (!obj.total) {\n      return {\n        total: 0,\n        operation: buttonName\n      };\n    }\n    return {\n      total: operate(obj.total, obj.next, obj.operation),\n      next: null,\n      operation: buttonName\n    };\n  }\n\n  // no operation yet, but the user typed one\n\n  // The user hasn't typed a number yet, just save the operation\n  if (!obj.next) {\n    return {\n      operation: buttonName\n    };\n  }\n\n  // save the operation and shift 'next' into 'total'\n  return {\n    total: obj.next,\n    next: null,\n    operation: buttonName\n  };\n}\nexport default calculate;","map":{"version":3,"names":["operate","isNumber","item","match","calculate","obj","buttonName","total","next","operation","includes","parseFloat","toString"],"sources":["/Volumes/Data/Programming /Microverse Course/Mircroverse_Course/math-magicians/src/logic/calculate.js"],"sourcesContent":["import operate from './operate';\n\nfunction isNumber(item) {\n  return !!item.match(/[0-9]+/);\n}\n\n/**\n * Given a button name and a calculator data object, return an updated\n * calculator data object.\n *\n * Calculator data object contains:\n *   total:s      the running total\n *   next:String       the next number to be operated on with the total\n *   operation:String  +, -, etc.\n */\nfunction calculate(obj, buttonName) {\n  if (buttonName === 'AC') {\n    return {\n      total: null,\n      next: null,\n      operation: null,\n    };\n  }\n\n  if (isNumber(buttonName)) {\n    if (buttonName === '0' && obj.next === '0') {\n      return {};\n    }\n    // If there is an operation, update next\n    if (obj.operation) {\n      if (obj.next && obj.next !== '0') {\n        return { ...obj, next: obj.next + buttonName };\n      }\n      return { ...obj, next: buttonName };\n    }\n    // If there is no operation, update next and clear the value\n    if (obj.next && obj.next !== '0') {\n      return {\n        next: obj.next + buttonName,\n        total: null,\n      };\n    }\n    return {\n      next: buttonName,\n      total: null,\n    };\n  }\n\n  if (buttonName === '.') {\n    if (obj.next) {\n      if (obj.next.includes('.')) {\n        return { ...obj };\n      }\n      return { ...obj, next: `${obj.next}.` };\n    }\n    if (obj.operation) {\n      return { ...obj, next: '0.' };\n    }\n    if (obj.total) {\n      if (obj.total.includes('.')) {\n        return {};\n      }\n      return { ...obj, next: `${obj.total}.` };\n    }\n    return { ...obj, next: '0.' };\n  }\n\n  if (buttonName === '=') {\n    if (obj.next && obj.operation) {\n      return {\n        total: operate(obj.total, obj.next, obj.operation),\n        next: null,\n        operation: null,\n      };\n    }\n    // '=' with no operation, nothing to do\n    return {};\n  }\n\n  if (buttonName === '+/-') {\n    if (obj.next) {\n      return { ...obj, next: (-1 * parseFloat(obj.next)).toString() };\n    }\n    if (obj.total) {\n      return { ...obj, total: (-1 * parseFloat(obj.total)).toString() };\n    }\n    return {};\n  }\n\n  // Button must be an operation\n\n  // When the user presses an operation button without having entered\n  // a number first, do nothing.\n  // if (!obj.next && !obj.total) {\n  //   return {};\n  // }\n\n  // User pressed an operation after pressing '='\n  if (!obj.next && obj.total && !obj.operation) {\n    return { ...obj, operation: buttonName };\n  }\n\n  // User pressed an operation button and there is an existing operation\n  if (obj.operation) {\n    if (obj.total && !obj.next) {\n      return { ...obj, operation: buttonName };\n    }\n    if (!obj.total) {\n      return { total: 0, operation: buttonName };\n    }\n\n    return {\n      total: operate(obj.total, obj.next, obj.operation),\n      next: null,\n      operation: buttonName,\n    };\n  }\n\n  // no operation yet, but the user typed one\n\n  // The user hasn't typed a number yet, just save the operation\n  if (!obj.next) {\n    return { operation: buttonName };\n  }\n\n  // save the operation and shift 'next' into 'total'\n  return {\n    total: obj.next,\n    next: null,\n    operation: buttonName,\n  };\n}\nexport default calculate;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}